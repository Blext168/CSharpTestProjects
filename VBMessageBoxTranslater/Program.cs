using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

class Program
{
    static Dictionary<string, string> stringToVarMap = new Dictionary<string, string>();
    static HashSet<string> existingVarNames = new HashSet<string>();
    static Dictionary<string, string> autoGenerated = new Dictionary<string, string>();
    static int autoStringCounter = 1;
    static string fileName = string.Empty;

    static void Main()
    {
        string variableFile = "C:\\Users\\Schiefer\\Downloads\\public.txt";
        string codeFile = "C:\\Users\\Schiefer\\Downloads\\FrmUmlagerungAuftrag.txt";
        string outputFile = "C:\\Users\\Schiefer\\Downloads\\New_FrmUmlagerungAuftrag.txt";
        string autoVarFile = "C:\\Users\\Schiefer\\Downloads\\AdditionalPublic.txt";

        fileName = codeFile.Split('\\').Last().Split('.').First();

        // ISO 8859-1 Encoding
        Encoding encoding = Encoding.Latin1;

        if (!File.Exists(variableFile) || !File.Exists(codeFile))
        {
            Console.WriteLine("Dateien fehlen.");
            return;
        }

        foreach (var line in File.ReadAllLines(variableFile, encoding))
            ParseStringAssignment(line);

        var codeLines = File.ReadAllLines(codeFile, encoding);
        var outputLines = ProcessCodeLines(codeLines);

        File.WriteAllLines(outputFile, outputLines, encoding);
        WriteAutoGeneratedVariables(autoVarFile, encoding);

        Console.WriteLine("Verarbeitung abgeschlossen.");
    }

    static void ParseStringAssignment(string line)
    {
        var regex = new Regex(@"(?i)(\w+)\s*=\s*""([^""]+)""");
        var match = regex.Match(line);
        if (match.Success)
        {
            string varName = match.Groups[1].Value;
            string stringValue = match.Groups[2].Value;
            if (!stringToVarMap.ContainsKey(stringValue))
                stringToVarMap[stringValue] = varName;

            existingVarNames.Add(varName);
        }
    }

    static string ProcessInputBoxLine(string line, string indentation)
    {
        var match = Regex.Match(line, @"InputBox\s*\((.*)\)", RegexOptions.IgnoreCase);
        if (!match.Success)
            return indentation + line;

        string content = match.Groups[1].Value;
        string[] parts = SplitParameters(content);
        if (parts.Length == 0)
            return indentation + line;

        string message = parts[0].Trim();
        string title = parts.Length > 1 ? parts[1].Trim() : null;

        string msgVar = GetOrCreateVariable(message, "inputMessageVariable");
        string titleVar = title != null ? GetOrCreateVariable(title, "inputTitleVariable") : null;

        string inputCall = titleVar != null
            ? $"InputBox({msgVar}, {titleVar})"
            : $"InputBox({msgVar})";

        return indentation + Regex.Replace(line, @"InputBox\s*\(.*\)", inputCall);
    }


    static string ProcessTitelzeileLine(string line, string indentation)
    {
        var match = Regex.Match(line, @"^(.*\.Titelzeile\s*=\s*)""([^""]+)""", RegexOptions.IgnoreCase);
        if (!match.Success)
            return indentation + line;

        string prefix = match.Groups[1].Value;
        string titleText = match.Groups[2].Value;

        string titleVar = GetOrCreateVariable($"\"{titleText}\"", "TitleVariable");

        return indentation + prefix + titleVar;
    }


    static string GetOrCreateVariable(string rawString, string prefix)
    {
        string cleaned = rawString.Trim().Trim('"');

        if (!stringToVarMap.TryGetValue(cleaned, out string varName))
        {
            varName = GenerateNamedVariable(prefix);
            stringToVarMap[cleaned] = varName;
            autoGenerated[varName] = cleaned;
        }

        return varName;
    }


    static List<string> ProcessCodeLines(string[] lines)
    {
        var output = new List<string>();
        int i = 0;

        while (i < lines.Length)
        {
            Console.Clear();
            float percentage = (float)i / (float)lines.Length;
            Console.WriteLine($"{Math.Round(percentage * 100, 0)}% - {i} von {lines.Length} Zeilen geschrieben.");

            string originalLine = lines[i];
            string trimmedLine = originalLine.TrimStart();
            string indentation = originalLine.Substring(0, originalLine.Length - trimmedLine.Length);

            // Kommentare und MsgBox in Kommentar ignorieren
            if (trimmedLine.StartsWith("'") ||
                (trimmedLine.Contains("MsgBox") && trimmedLine.Contains("'") &&
                 trimmedLine.IndexOf("MsgBox", StringComparison.OrdinalIgnoreCase) > trimmedLine.IndexOf("'")))
            {
                output.Add(originalLine);
                i++;
                continue;
            }

            // Mehrzeilige MsgBox erkennen
            if (trimmedLine.StartsWith("MsgBox", StringComparison.OrdinalIgnoreCase))
            {
                var msgBoxLines = new List<string> { trimmedLine };
                while (msgBoxLines[^1].TrimEnd().EndsWith("_") && i + 1 < lines.Length)
                {
                    i++;
                    msgBoxLines.Add(lines[i].Trim());
                }

                string combined = string.Join(" ", msgBoxLines).Replace(" _", "").Trim();
                string processed = ProcessMsgBoxLine(combined, indentation);
                output.Add(processed);
                i++;
                continue;
            }

            // MsgBox in Zuweisung
            if (Regex.IsMatch(trimmedLine, @"=\s*MsgBox\s*\(", RegexOptions.IgnoreCase))
            {
                string processed = ProcessMsgBoxLine(trimmedLine, indentation);
                output.Add(processed);
                i++;
                continue;
            }

            // InputBox erkennen
            if (Regex.IsMatch(trimmedLine, @"InputBox\s*\(", RegexOptions.IgnoreCase))
            {
                string processed = ProcessInputBoxLine(trimmedLine, indentation);
                output.Add(processed);
                i++;
                continue;
            }

            // Titelzeile-Zuweisung
            if (Regex.IsMatch(trimmedLine, @"\.Titelzeile\s*=\s*""", RegexOptions.IgnoreCase) ||
                Regex.IsMatch(trimmedLine, @"\.Infotext\s*=\s*""", RegexOptions.IgnoreCase))
            {
                string processed = ProcessTitelzeileLine(trimmedLine, indentation);
                output.Add(processed);
                i++;
                continue;
            }

            // Standardzeile übernehmen
            output.Add(originalLine);
            i++;
        }

        return output;
    }


    static string ProcessMsgBoxLine(string line, string indentation)
    {
        // Nur auf MsgBox-Zeilen anwenden
        if (!line.TrimStart().StartsWith("MsgBox", StringComparison.OrdinalIgnoreCase))
            return indentation + line;

        // Inhalt nach MsgBox extrahieren
        var match = Regex.Match(line, @"MsgBox\s+(.*)", RegexOptions.IgnoreCase);
        if (!match.Success)
            return indentation + line;

        string argumentsPart = match.Groups[1].Value;

        // Zerlege anhand von Kommas in Parameter
        string[] parameters = SplitParameters(argumentsPart);

        if (parameters.Length == 0)
            return indentation + line;

        string textExpression = parameters[0].Trim();
        string formattedText = ProcessTextExpression(textExpression, out string messageVar);

        // Optionaler Titel
        if (parameters.Length >= 3)
        {
            string titleParam = parameters[2].Trim();
            if (titleParam.StartsWith("\"") && titleParam.EndsWith("\""))
            {
                string titleText = titleParam.Substring(1, titleParam.Length - 2);
                if (!stringToVarMap.TryGetValue(titleText, out string titleVar))
                {
                    titleVar = GenerateNamedVariable("TitleVariable");
                    stringToVarMap[titleText] = titleVar;
                    autoGenerated[titleVar] = titleText;
                }
                parameters[2] = titleVar;
            }
        }

        parameters[0] = formattedText;

        return indentation + "MsgBox " + string.Join(", ", parameters);
    }

    static string ProcessTextExpression(string expression, out string variableName)
    {
        var parts = Regex.Split(expression, @"\s*&\s*");
        var formatParts = new List<string>();
        var args = new List<string>();

        foreach (var part in parts)
        {
            string trimmed = part.Trim();
            if (trimmed.StartsWith("\"") && trimmed.EndsWith("\""))
            {
                string content = trimmed.Substring(1, trimmed.Length - 2);
                formatParts.Add(content);
            }
            else
            {
                formatParts.Add("{" + args.Count + "}");
                args.Add(trimmed);
            }
        }

        string formatString = string.Join("", formatParts);

        // Variable erzeugen oder nachschlagen
        if (!stringToVarMap.TryGetValue(formatString, out variableName))
        {
            variableName = GenerateNamedVariable("MessageVariable");
            stringToVarMap[formatString] = variableName;
            autoGenerated[variableName] = formatString;
        }

        return args.Count > 0
            ? $"Format({variableName}, {string.Join(", ", args)})"
            : variableName;
    }

    static string GenerateNamedVariable(string prefix)
    {
        int counter = 1;
        string name;
        do
        {
            name = $"g{fileName}{prefix}{counter++}";
        } while (existingVarNames.Contains(name));
        existingVarNames.Add(name);
        return name;
    }


    static string GenerateNewVariableName()
    {
        string baseName;
        do
        {
            baseName = $"autoString{autoStringCounter++}";
        } while (existingVarNames.Contains(baseName));

        existingVarNames.Add(baseName);
        return baseName;
    }

    static string[] SplitParameters(string input)
    {
        var parameters = new List<string>();
        var sb = new StringBuilder();
        bool inString = false;

        for (int i = 0; i < input.Length; i++)
        {
            char c = input[i];

            if (c == '"')
            {
                inString = !inString;
                sb.Append(c);
            }
            else if (c == ',' && !inString)
            {
                parameters.Add(sb.ToString().Trim());
                sb.Clear();
            }
            else
            {
                sb.Append(c);
            }
        }

        if (sb.Length > 0)
            parameters.Add(sb.ToString().Trim());

        return parameters.ToArray();
    }


    static void WriteAutoGeneratedVariables(string filePath, Encoding encoding)
    {
        var lines = new List<string>();
        foreach (var kvp in autoGenerated)
        {
            string varLine = $"Global {kvp.Key} As String = \"{kvp.Value}\"";
            lines.Add(varLine);
        }

        if (lines.Count > 0)
            File.WriteAllLines(filePath, lines, encoding);
    }
}
